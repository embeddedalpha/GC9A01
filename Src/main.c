/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include "main.h"
#include "Console.h"
#include "GC9A01.h"
#include "math.h"

GC9A01_Typedef display;
struct GC9A01_frame frame;

struct GC9A01_frame frame1;
struct GC9A01_frame frame2;
struct GC9A01_frame frame3;

volatile uint16_t buffer[240][240];
uint8_t color[3];

void GC9A01_Flash()
{
	frame.start.X = 0;
	frame.start.Y =  0;
	frame.end.X = 240;
	frame.end.Y = 240;
	GC9A01_Set_Frame(&display,frame);
	color[0] = 0x00;
	color[1] = 0x00;
	color[2] = 0x00;
	for (int x = 0; x < 240; x++) {
        for (int y = 0; y < 240; y++)
        {
           GC9A01_Write_Continue(&display,color, sizeof(color));
        }
    }
}

int main(void)
{
	MCU_Clock_Setup();
	Delay_Config();
	Console_Init(USART1, 9600);
//	Delay_s(2);

	// test this part
//	GC9A01_DeInit(&display);

	display.SPI_Driver.NSS_Pin = 1;
	display.SPI_Driver.NSS_Port = GPIOA;
	display.SPI_Driver.Port = SPI1;
	display.SPI_Driver.clock_phase = SPI_Clock_Phase.Low_0;
	display.SPI_Driver.clock_pin = SPI1_CLK.PA5;
	display.SPI_Driver.clock_polarity = SPI_Clock_Polarity.Low_0;
	display.SPI_Driver.crc = SPI_CRC.Disable;
	display.SPI_Driver.data_format = SPI_Data_Format.Bit8;
	display.SPI_Driver.dma = SPI_DMA.RX_DMA_Disable;
	display.SPI_Driver.frame_format = SPI_Frame_Format.MSB_First;
	display.SPI_Driver.interrupt = SPI_Interrupt.Disable;
	display.SPI_Driver.miso_pin = SPI1_MISO.PA6;
	display.SPI_Driver.mode = SPI_Mode.Full_Duplex_Master;
	display.SPI_Driver.mosi_pin = SPI1_MOSI.PA7;
	display.SPI_Driver.prescaler = SPI_Prescaler.CLK_div_2;
	display.SPI_Driver.type = SPI_Type.Master;

	display.DC_Port = GPIOA;
	display.DC_Pin = 3;

	display.Reset_Port = GPIOA;
	display.Reset_Pin = 2;

	GC9A01_Init(&display);





//	for(int i = 100; i < 200; i++)
//	{
//		for(int j = 100; j < 200; j++)
//		{
//			frame.start.X = i;
//			frame.start.Y =  i;
//			frame.end.X = j;
//			frame.end.Y = j;
//			GC9A01_Set_Frame(&display,frame);
//			GC9A01_Write_Continue(&display,color, 0xFFFFFF);
//			Delay_s(1);
//		}
//	}


	uint32_t rgb = 0xDDffEE;


		GC9A01_Draw_Pixel(&display, 120, 120, rgb);
//		GC9A01_Draw_Pixel(&display, 200, 201, rgb);
//		GC9A01_Draw_Pixel(&display, 200, 202, rgb);
//		GC9A01_Draw_Pixel(&display, 200, 203, rgb);
//		GC9A01_Draw_Pixel(&display, 200, 204, rgb);
//		GC9A01_Draw_Pixel(&display, 200, 205, rgb);
//		GC9A01_Draw_Pixel(&display, 200, 206, rgb);
//		GC9A01_Draw_Pixel(&display, 200, 207, rgb);
//		GC9A01_Draw_Pixel(&display, 200, 208, rgb);
//		GC9A01_Draw_Pixel(&display, 200, 209, rgb);
//		Delay_ms(900);

		uint8_t width = 90;
		uint8_t height = 90;

	for(;;)
	{
		GC9A01_Flash();
		Delay_s(1);

		for(int i = 100; i < 200; i++)
		{
			GC9A01_Draw_Point(&display, i, i, 0xFFffff);
			Delay_s(1);
		}






//		frame1.start.X = 40;
//		frame1.start.Y =  70;
//		frame1.end.X = frame1.start.X + width;
//		frame1.end.Y = frame1.start.Y + height;
//		GC9A01_Set_Frame(&display,frame1);
//
//		color[0] = 0x00;
//		color[1] = 0x00;
//		color[2] = 0x00;
//		for (int x = 0; x < width; x++) {
//            for (int y = 0; y < height; y++)
//            {
////                if (x == 0 && y == 0)
////                {
////                	GC9A01_Write(&display,color, sizeof(color));
////                } else
//                {
//                	GC9A01_Write_Continue(&display,color, sizeof(color));
//                }
//                Delay_ms(600);
//            }
//        }
//            Delay_s(1);
//
//    		color[0] = 0x12;
//    		color[1] = 0x67;
//    		color[2] = 0x98;
//    		for (int x = 0; x < width+width; x++) {
//                for (int y = 0; y < height+height; y++)
//                {
////                    if (x == 0 && y == 0) {
////                    	GC9A01_Write(&display,color, sizeof(color));
////                    }
////                    else
//                    {
//                    	GC9A01_Write_Continue(&display,color, sizeof(color));
//                    }
//                }
//            }
//                Delay_s(1);
//
//
//        		frame2.start.X =  70;
//        		frame2.start.Y = 70;
//        		frame2.end.X = 170;
//        		frame2.end.Y = 170;
//        		GC9A01_Set_Frame(&display,frame2);
//
//        		color[0] = 0xff;
//        		color[1] = 0xff;
//        		color[2] = 0xff;
//        		for (int x = 0; x < width; x++) {
//                    for (int y = 0; y < width; y++)
//                    {
////                        if (x == 0 && y == 0) {
////                        	GC9A01_Write(&display,color, sizeof(color));
////                        }
////                        else
//                        {
//                        	GC9A01_Write_Continue(&display,color, sizeof(color));
//                        }
//                    }
//                }
//                    Delay_s(1);
//
//
//



	}
}
